# Protojure

Protojure is first-class [Clojure](https://clojure.org/) support for 
[Protocol Buffers](https://developers.google.com/protocol-buffers/) and [gRPC Services](https://grpc.io/)

[https://github.com/protojure](https://github.com/protojure)

### Etymology

Protojure is a portmanteau of **Proto**-col Buffers and Clo-**jure**

### Table of Contents

* [Protoc-plugin Installation](#protoc-gen-clojure-installation)
* [Quick Start](#quick-start)
* [Status](#status)
* [Features](#features)
* [Protocol Buffers in clj](#protocol-buffers-in-clj)
* [gRPC Services in clj](#grpc-services-in-clj)
* [Unary Endpoint Examples](#unary-endpoint-example)
* [Streaming Examples](#server-streaming-example)
* [Clojure Docs](#clojure-docs)
* [Contributing](#contributing)

### Protoc-plugin Installation

As a first step to follow along with the tutorials here, please clone 
[protoc-plugin](https://github.com/protojure/protoc-plugin) and run
```
make bin
make install
```

This and all following steps rely on the presence of a jdk and [Leiningen](https://leiningen.org/)

### Quick Start

#### Quick Start Prerequisites:
1. [Leiningen](https://leiningen.org/)
2. [Protoc](https://github.com/protocolbuffers/protobuf/releases/tag/v3.9.1)

#### Quick Start Guide:

Run `lein new protojure <your project name>`

This instantiates a leiningen template that creates a
runnable application hosting gRPC endpoints. 

Refer to the README.md in the created project for instructions on how to use your
own `.proto` Protocol Buffer and gRPC Service definitions.

### Status

[CircleCI-hosted master branch & PR builds](https://circleci.com/gh/protojure)

### Features
Features

First class Clojure support for Google [Protocol Buffers](https://developers.google.com/protocol-buffers/) and 
[gRPC Services](https://grpc.io/)

* Supports Protobuf message serialization (tested with proto3 format)
* Support for GRPC Clients and Servers
* In-process [GRPC-WEB](https://github.com/grpc/grpc-web) Proxy
* core.async based GRPC streaming
* Integration with the [Pedestal](https://github.com/pedestal/pedestal) web framework included, and extensible to support others (Ring, Compojure, etc)

### Protocol Buffers in clj

Below is a simple [`.proto`](https://developers.google.com/protocol-buffers/) Protocol Buffer (protobuf or pb) definition:

```
syntax = "proto3";
package com.example.addressbook;

message Person {
    string name = 1;
    int32 id = 2;  // Unique ID number for this person.
    string email = 3;

    enum PhoneType {
        MOBILE = 0;
        HOME = 1;
        WORK = 2;
    }

    message PhoneNumber {
        string number = 1;
        PhoneType type = 2;
    }

    repeated PhoneNumber phones = 4;
}

message AddressBook {
    repeated Person people = 1;
}

```

Given the above contents in a file, `addressbook.proto`, in our current directory, we may use the protojure
[protoc plugin](https://github.com/protojure/protoc-plugin) to generate .clj language bindings:
```
mkdir src/
protoc --clojure_out=src/ addressbook.proto
```

After running the above, we will find a nested directory structure corresponding to the package above 
(`com.example`):

```

$ cat src/com/example/addressbook.clj 
;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package com.example.addressbook
;;;----------------------------------------------------------------------------------
...
..
. <File contents continues -- run the `cat` command above to see your generated output in full>
```

We can create a `project.clj` file alongside our project file:
```
(defproject protojure-tutorial "0.0.1-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Apache License 2.0"
            :url "https://www.apache.org/licenses/LICENSE-2.0"
            :year 2019
            :key "apache-2.0"}
  :dependencies [[org.clojure/clojure "1.10.0"]

                 ;; -- PROTOC-GEN-CLOJURE --
                 [protojure "1.0.0"]
                 [com.google.protobuf/protobuf-java "3.6.1"]])

```

Now, running `lein repl`:

```
$ lein repl
nREPL server started on port 35997 on host 127.0.0.1 - nrepl://127.0.0.1:35997
WARNING: cat already refers to: #'clojure.core/cat in namespace: net.cgrand.regex, being replaced by: #'net.cgrand.regex/cat
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.10.0
OpenJDK 64-Bit Server VM 1.8.0_222-8u222-b10-1ubuntu1~18.04.1-b10
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=> (use 'com.example.addressbook)
nil
```

We create clojure representations of protobuf messages by requiring the appropriate ns generated by the protojure protoc
plugin, as above, and then exercising the `new-<Pb-message-name-here` like so:

```
user=> (new-Person {:name "Jane Doe"})
#com.example.addressbook.Person{:name "Jane Doe", :id 0, :email "", :phones []}
```

We can then seralize this in-memory clj representation of the pb message to the protocol buffer bytes serialization by
requiring the `protojure.protobuf` namespace from the [protojure lib](https://github.com/protojure/lib):

```
user=> (require '[protojure.protobuf :as protojure])
nil
user=> (protojure/->pb (new-Person {:name "Jane Doe"}))
#object["[B" 0x11398205 "[B@11398205"]
```
For illustration purposes, here is the native java byte array in a clojure vector:
```
user=> (into [] (protojure/->pb (new-Person {:name "Jane Doe"})))
[10 8 74 97 110 101 32 68 111 101]
```
In order to deseralize an array of bytes, we use the `pb-><Message name here>` form from the generated code (here, our
ns `com.example.addressbook`):
```
user=> (pb->Person (byte-array [10 8 74 97 110 101 32 68 111 101]))
#com.example.addressbook.Person{:name "Jane Doe", :id 0, :email "", :phones []}
```

You've now round tripped a Protocol Buffer message from definition, to .clj language bindings, to in-memory 
clj representation to bytes and back to the in-memory form!

## gRPC Services in clj

gRPC is a "high performance, open-source universal RPC framework".

For those without any prior gRPC experience, gRPC is a standardized way of communicating between processes, often over
a network, whether within a data center or across the wider internet.

Below is a simple [gRPC](https://grpc.io/) service definition:

```
syntax = "proto3";
package com.example.addressbook;

message Person {
    string name = 1;
}

message AddressBook {
    repeated Person people = 1;
}

message HelloResponse {
    string message = 1;
}

service Greeter {
    rpc Hello (Person) returns (HelloResponse);
}

```

The service definition defines an endpoint (often reachable at some well-known URL or IP), called Greeter. The Greeter service
exposes a method called Hello. We may interact with the Hello method by contacting the Greeter service and sending
a HelloRequest message. Refer to [Protocol Buffers in clj](#protocol-buffers-in-clj) above for a walkthrough of protobuf
with protojure. 

The message definition of HelloResponse is just like the `message Person` definition discussed in the previous section.

Assume we have a terminal open locally, and that the
[`hello` example](https://github.com/protojure/protoc-plugin/tree/master/examples/hello) from the
[Protojure protoc-plugin](https://github.com/protojure/protoc-plugin/tree/master/examples/hello) repository is running
locally (perhaps by having cloned that repository, opening a different terminal, and running `lein run` from the cloned
repository root directory).

From our terminal, cd to a directory of your choice and populate `greeter.proto` with the contents of the first code
block at the start of this section that begins:

```

syntax = "proto3";
package com.example.addressbook;

message Person {
...
```

Now, run:
```
protoc --clojure_out=grpc-client:. greeter.proto
```

If we check the contents of our directory, we will now also see a folder called `com/`. Inside is our generated gRPC
client code.

If we create another file called `project.clj` in our current directory with contents:

```
(defproject protojure-tutorial "0.0.1-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Apache License 2.0"
            :url "https://www.apache.org/licenses/LICENSE-2.0"
            :year 2019
            :key "apache-2.0"}
  :dependencies [[org.clojure/clojure "1.10.0"]

                 ;; -- PROTOC-GEN-CLOJURE --
                 [protojure "1.0.0"]
                 [com.google.protobuf/protobuf-java "3.6.1"]
                 ;; -- PROTOC-GEN-CLOJURE HTTP/2 Client Lib Dependency --
                 [org.eclipse.jetty.http2/http2-client "9.4.17.v20190418"]]
  :source-paths ["."])



```
save it, open a repl and try to `use` the generated namespace, we will see output similar to the below:
```
$ lein repl
nREPL server started on port 34903 on host 127.0.0.1 - nrepl://127.0.0.1:34903
WARNING: cat already refers to: #'clojure.core/cat in namespace: net.cgrand.regex, being replaced by: #'net.cgrand.regex/cat
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.10.0
OpenJDK 64-Bit Server VM 1.8.0_222-8u222-b10-1ubuntu1~18.04.1-b10
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=> (use 'com.example.addressbook.Greeter)
WARNING: take already refers to: #'clojure.core/take in namespace: protojure.grpc.client.utils, being replaced by: #'protojure.grpc.client.utils/take
nil

```

We can see that one of the var's refer'd into our repl is `call-Hello`:
```
user=> ca<Tab for auto complete options>
call-Hello 
```

In order to invoke the client call, we'll need to create a client. We do this by requiring the protojure-lib ns below:
```
user=> (require '[protojure.grpc.client.providers.http2 :as grpc.http2])
nil
```
And creating a client connection:
```
user=> (def client @(grpc.http2/connect {:uri "http://localhost:8080"}))
#'user/client
```
Note: The `@` is a syntactic shortcut within [clojure for promises](https://clojuredocs.org/clojure.core/promise).
Without the deref, we would be interring a ref to the client 'Promise', not the eventually returned connected client.

Now we can use our `call-Hello` function from above, and with the protoc-plugin example `hello` running we will receive
a HelloResponse message (you can see this message defined in the `greeter.proto` content above):
```
user=> @(call-Hello client {:name "Janet Johnathan Doe"})
#com.example.addressbook.HelloResponse{:message "Hello, Janet Johnathan Doe"}

```

In the logs of the running protoc-plugin `hello` example we will see:

```
INFO  io.pedestal.http - {:msg "POST /com.example.addressbook.Greeter/Hello", :line 80}
```

With a utility like `tcpdump` or wireshark, we would also see packets on our local network between the repl and server.

Congratulations, you've invoked a remote procedure call round trip with the GRPC protocol using Clojure on both ends. 
You may now interoperate with a client or server written in any other language that adheres to the GRPC and .proto spec.

# Further examples


## Clojure gRPC Client Connect Example

```
@(grpc.http2/connect {:uri (str "http://localhost:" port) :content-coding "gzip"})
```

### Unary Endpoint Example
[Protocol Buffer Definition](https://github.com/protojure/protoc-plugin/blob/master/examples/hello/resources/addressbook.proto)
```
syntax = "proto3";
package com.example.addressbook;

message Person {
    string name = 1;
    int32 id = 2;  // Unique ID number for this person.
    string email = 3;

    enum PhoneType {
        MOBILE = 0;
        HOME = 1;
        WORK = 2;
    }

    message PhoneNumber {
        string number = 1;
        PhoneType type = 2;
    }

    repeated PhoneNumber phones = 4;
}

```
```
message HelloResponse {
    string message = 1;
}

```
* gRPC Service Definition
```
service Greeter {
    rpc Hello (Person) returns (HelloResponse);
}
```

* Client
```
@(call-Hello @(grpc.http2/connect {:uri "http://localhost:8080"}) {:name "Janet Johnathan Doe"})
```
* Server Handler

{% raw %}
```
(deftype Greeter []
  greeter/Service
  (Hello
    [this {{:keys [name]} :grpc-params :as request}]
    {:status 200
     :body {:message (str "Hello, " name)}}))
```
{% endraw %}

Include the below in the interceptors passed to
the pedestal routes key:

```
(proutes/->tablesyntax {:rpc-metadata greeter/rpc-metadata 
                        :interceptors common-interceptors 
                        :callback-context (Greeter.)})
```

Refer to [src/hello](https://github.com/protojure/protoc-plugin/tree/master/examples/hello/src/hello) in the hello example
in the `examples/` dir of protoc-plugin [here](https://github.com/protojure/protoc-plugin/tree/master/examples/hello) 

You can find an additional unary client and server example (a runnable one) in the boilerplate generated by 'lein new protojure'

### Server Streaming Example

Simply return a [core.async](https://github.com/clojure/core.async) 
[channel](https://clojuredocs.org/clojure.core.async/chan) in the :body key returned by your interceptor handler
instead of a map as above in the unary example

* Server
{% raw %}
```
(deftype Greeter []
  greeter/Service
  (SayRepeatHello
    [this {{:keys [name]} :grpc-params :as request}]
    (let [resp-chan (:grpc-out request)]
      (go
        (dotimes [_ 3]
          (>! resp-chan {:message (str "Hello, " name)}))
        (async/close! resp-chan))
      {:status 200
       :body resp-chan})))
```
{% endraw %}


### Client Streaming Example
Identical to the above Client example for unary -- instead of closing the channels after pushing a single map,
keep the core.async channel open and push maps as needed.

See the streaming-grpc-check test in Protojure lib's [grpc_test.clj](https://github.com/protojure/lib/blob/master/test/protojure/grpc_test.clj)

Excerpt:

```
    (let [repetitions 50
          input (async/chan repetitions)
          output (async/chan repetitions)
          client (:grpc-client @test-env)
          desc {:service "example.hello.Greeter"
                :method "SayHelloOnDemand"
                :input {:f new-HelloRequest :ch input}
                :output {:f pb->HelloReply :ch output}}]

      (async/onto-chan input (repeat repetitions {:name "World"}))

      @(-> (grpc/invoke client desc)
```

### Clojure Docs
* [Protojure lib cljdoc](https://cljdoc.org/d/protojure/protojure/1.0.0)

### Contributing

We cannot (yet) accept outside contributions to the code base at this time. Please check for updates in the future regarding acceptance of outside contributions.
